# comp110-journal
# 1. When does a physical system compute?

This journal looks into how we define a computation device and also how we know when a computation is happening. Physical computation is defined as a physical system performing internal interactions, which consists of abstract entity, computation input and produces an output. We should feel confident that the output is correct. With this theory, the authors use a series of computing diagrams that can be used on many different systems, e.g. a computers abstract entity refers to its programming in a physical system. Other examples include a computing system which must also be capable of encoding, decoding and embedding. The article then goes into greater depth and dicusses how inputs are broken down into smaller operations in standard gate-based computers, which is what this journal concentrates on. Furthermore, physical computational devices are capable of changing high-level assembly language into low-level assembly language (1, 0) without human input. Though computational output can change depending on the words (such as AND, OR, NOT) used to program a process. The main factor that defines a computational device is the ability to encode and decode, without this there is no computation and it would just be considered a physical system. Computational devices are also used to simulate anything using virtual environments.

In conclusion, this paper highlights the fact that everyone has a different idea of what a computational device is and this journal concentrated on the framework of the devices, whilst also stating that a human could themselves be a computational entity. I agree about the importance of encoding and decoding in computing in regards to defining a computational device.

# 2. Experimental investigations of the utility of detailed flowcharts in programming

As the title of this article makes obvious it discusses flowcharts in relation to computer programming, scince computers were first created flow charts have been used to describe and help explain computational processes, as programming languages became more complex as did the flowchart, becoming more structured, but even so more porgrammers argued if flowcharts were useful or hindering the way programming was taught. Prevous experimental research found those who used flowcharts were better at knowing the parts needed to make a programme but not understanding other tasks. The authors did their own set of experiments five in total, in which students were beginning to learn programming were divided into a group using flowcharts and a group that wasn't. Experiment 2 studied how flowcharts helped the student compose a program to help solve a cetain problem, the flowchart group did just aswell as the nonflowchart group. Experiment 2 looked into if flowcharts helped with programming comprehension, the subjects were required to determine the values printed for
various inputs and to trace the flow of execution, again there was no notable difference between the flowchart and non-flowchart group. Experiment 3, the students are no longer novices and the flowcharts were used to help with debugging and comprehension, the results of this experiment showed it depended very much on the persons experience with flowcharts on whether it helped or not with their work but the difference between the flowchart and nonflowchart group was not a very significant one. Experiment 4 second year students used flowcharts to help them modify a programme, again no great difference in results of thse that recieved a floechart and those that did not. Experiment 5

# 3. A fast procedure for computing the distance between complex objects in three-dimensional space 
# 4. Statement considered harmful
